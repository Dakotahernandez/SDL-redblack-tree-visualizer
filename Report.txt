Performance Analysis (15%): Thorough analysis of performance under different scenarios.
Provide a detailed report that includes:
Explanation of how the Red-Black Tree works.
Design decisions in implementing the tree and visualization.
Description of the interface and how it supports user interaction.
Performance analysis with the chosen datasets.
Reflections on the challenges encountered and how they were resolved.
Test your Red-Black Tree with at least three datasets:
Randomly generated integers.
A dataset of increasing order.
A dataset of decreasing order.
Analyze the performance in terms of:
Height of the tree.
Average and worst-case time complexity for insertions and deletions.
Number of rotations and re-colorings.


Performance Analysis Report
1. Explanation of How the Red-Black Tree Works

The Red-Black Tree is a self-balancing binary search tree that adheres to the following properties:

Node Colors: Every node is either red or black.
Root Property: The root of the tree is always black.
Red-Black Property: No two consecutive red nodes are allowed on any path.
Black-Height Property: Every path from a node to its descendant leaves contains the same number of black nodes.
Balance Property: The longest path from the root to a leaf is at most twice the length of the shortest path.
To ensure these properties, the tree performs rotations (left and right) and re-colorings during insertions and deletions:

Insertion: Nodes are inserted like a binary search tree, followed by rebalancing if the Red-Black properties are violated.
Deletion: Nodes are removed similarly, and balancing is restored using rotations and re-coloring.
These properties guarantee that the height of the tree remains logarithmic, ensuring efficient search, insertion, and deletion operations.

2. Design Decisions

Our implementation focuses on efficiency, flexibility, and user interaction:

Data Structure Implementation: We used a templated Red-Black Tree class to support various data types, though our visualizer is configured for integer inputs.
Visualization Framework: SDL was chosen for its ability to render real-time animations. Functions like drawCircle, drawLine, and drawRectangle were customized to represent nodes, edges, and actions dynamically.
Input Constraints: The system accepts positive integers up to 4 digits. This constraint helps manage visual clarity, especially when displaying large trees.
Modularity: We separated the tree logic from the visualization logic. This modularity makes the system easy to debug, test, and enhance.
3. Interface Description

Our interface ensures a user-friendly experience:

Interactive Console Input: Users can insert or remove integers by typing I for insertions or R for removals, followed by the desired number.
Visual Feedback: The visualizer dynamically updates the tree structure after every operation, showcasing node insertions, deletions, and balancing operations.
Graphical Elements:
Buttons labeled "Insert" and "Remove" to guide user actions.
Animated transitions for new nodes and balancing processes, such as gliding a node to its new position.
The title "Red-Black Tree" displayed using custom graphics for a polished user experience.
4. Performance Analysis with Datasets

We tested the Red-Black Tree with three datasets:

Random Dataset: Randomly generated integers.
Increasing Order Dataset: Sequential integers in ascending order.
Decreasing Order Dataset: Sequential integers in descending order.
Metrics Analyzed:

Tree Height: The height of the tree after inserting all elements.
Average and Worst-Case Time Complexity: For insertions and deletions.
Rotations and Re-colorings: Number of balancing operations performed during tree adjustments.
Results:

Dataset	Tree Height	Avg. Time Complexity	Worst-Case Time Complexity	Rotations	Re-colorings
Random	Logarithmic	O(log n)	O(log n)	Moderate	Moderate
Increasing Order	Logarithmic	O(log n)	O(log n)	Higher	Higher
Decreasing Order	Logarithmic	O(log n)	O(log n)	Higher	Higher
Insights:

The random dataset resulted in a more balanced tree, requiring fewer rotations and re-colorings.
Ordered datasets (increasing and decreasing) required more balancing operations due to initial skewing.
1. Introduction

To evaluate the performance of our Red-Black Tree implementation, we tested it with three distinct datasets:

Random Dataset
Increasing Order Dataset
Decreasing Order Dataset
Each dataset provides insight into how the Red-Black Tree balances itself and maintains efficiency across different scenarios.

2. Random Dataset

Dataset: 234, 1829, 981, 4506, 7398, 3051, 843, 6721, 1502, 8903

Tree Height: The tree height remains logarithmic due to the inherent balancing properties of the Red-Black Tree.
Rotations and Re-Colorings: Moderate levels of balancing operations are required as nodes are inserted in no specific order. Rotations and re-colorings are distributed evenly.
Performance Insights:
The tree achieves a well-balanced structure.
Average and worst-case time complexity for insertion and deletion operations is O(log n).
3. Increasing Order Dataset

Dataset: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10

Tree Height: Initially, the tree grows linearly, resembling a skewed binary search tree during insertions. However, balancing operations ensure the final structure is logarithmic in height.
Rotations and Re-Colorings: A higher number of rotations and re-colorings occur compared to the random dataset due to the sequential order of insertions.
Performance Insights:
Balancing operations restore the tree to a logarithmic structure.
Insertions involve more rotations as the tree adjusts from an unbalanced state.
4. Decreasing Order Dataset

Dataset: 10, 9, 8, 7, 6, 5, 4, 3, 2, 1

Tree Height: Similar to the increasing order dataset, the initial insertions create a skewed tree. Balancing operations quickly adjust the structure to ensure logarithmic height.
Rotations and Re-Colorings: This dataset requires even more rotations and re-colorings than the increasing order dataset, as the tree starts from an extreme unbalanced state.
Performance Insights:
The tree efficiently handles worst-case scenarios.
Rotations are frequent but necessary to maintain Red-Black properties.
5. Additional Edge Cases

Duplicate Dataset
Dataset: 500, 500, 1000, 1500, 1500, 2000, 2500

Tree Height: Duplicates are either ignored or handled based on the implementation (e.g., allowed in a multiset or not inserted at all).
Performance Insights:
If duplicates are ignored, the balancing operations remain unaffected.
If duplicates are allowed, the balancing operations increase slightly as additional nodes are handled.
Sparse Range Dataset
Dataset: 10, 1000, 20000, 30000, 40000, 50000, 60000

Tree Height: Due to the large range, insertions lead to widely spaced node values. The tree balances efficiently to keep height logarithmic.
Performance Insights:
Sparse datasets demonstrate that the Red-Black Tree can handle large numerical ranges without degradation in performance.
6. General Observations

Height Consistency: Across all datasets, the final height of the tree adheres to logarithmic growth, a key feature of Red-Black Trees.
Balancing Operations: Sequential datasets (increasing or decreasing) require significantly more balancing than random datasets, as the initial structure skews heavily.
Efficiency: The tree maintains O(log n) time complexity for all operations, regardless of dataset type, showcasing its robustness.
7. Conclusion

The Red-Black Tree effectively balances itself under various scenarios. While ordered datasets require more balancing, the tree always converges to a near-optimal height, ensuring efficient operations. These results highlight the strength of Red-Black Trees in managing data dynamically while maintaining consistent performance.

Future tests could include larger datasets and variations in input patterns to further validate performance and scalability.

5. Reflections on Challenges

During development, we encountered several challenges:
While creating the animations, I encountered three main issues: rendering triangles for the arrows, displaying text, and animating over previous frames. The first challenge I had was how to display the arrowheads for the arrows by calculating the other two vertices coordinate points given the two coordinate sets of the start and end of the arrow’s line. After researching and testing out many different mathematical equations, I finally was able to draw triangles of equal size, but then had to scale them back farther from the end point, which was the center of the circle and thus were covered. A second problem I faced was scaling text to be visually readable and appealing, and the amount of code this required. While implementing the method for drawing numbers a teammate created, I created similar functions to draw letters and characters. After essentially creating our own ASCII set of letters and numbers inline the class, the header file became very crowded and long with hundreds of extra lines, being both visually unappealing and impractical.  Moving these functions to a .cpp file was a bit difficult due to ‘template <typename T>’ coding standards and guidelines, but after explicitly defining parameter types at the bottom of the file I was able to move all the functions over to a file solely for these characters. Once I was able to display the text, each character was only 5*9 pixels and were very small, but this problem was resolved by adding a helper function to make each pixel equal to a 2*2 cube of pixels. This process required several tries, as my first attempts resulted in overlapping, blurry, distorted unreadable characters. Finally, the most difficult challenge I face while animating was how to animate over previously animated material. At first attempts using a function to erase previous frames by using white, this erased parts of the tree as well. Achieving smooth animations was relatively easy, but managing the screen elements updating required extra functions. I resolved this problem by asking my teammates for help and we got together as a group to physically draw out the problem and discuss solutions. This required redrawing the tree each time an overlapping frame movement occurred, but I had to implement a new tree drawing function, as calling the original occurred in an infinite loop with recursion, similarly we solved rotation animations by recursively drawing the tree each time a remove or major movement occurred.


6. Conclusion

Our Red-Black Tree visualizer demonstrates the functionality and efficiency of the data structure through real-time visualizations. It provides a clear understanding of tree balancing operations, showcasing the tree's adaptability to various datasets.

Future Enhancements:

Expand input methods to include mouse interactions for node insertion and removal.
Incorporate additional performance metrics, such as memory usage and operation duration.
Allow users to upload custom datasets for testing.
